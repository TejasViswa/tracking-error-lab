---
title: "Advanced Topics: AR(1) Processes, Newey-West Estimation, and Consistent Annualization"
subtitle: "Rigorous mathematical treatment with closed-form solutions and estimation procedures"
format:
  html:
    toc: true
    theme: cosmo
    code-fold: true
---

## Overview

This page provides advanced mathematical tools for tracking error analysis, building on the intuitive derivations from the previous pages. We cover:

1. **General autocovariance aggregation formulas** — for arbitrary serial correlation structures
2. **AR(1) closed-form solutions** — explicit formulas for first-order autoregressive processes
3. **Newey-West estimation** — robust long-run variance estimators for annualization
4. **Practical implementation** — Python code for real-world applications

**Prerequisites:** Familiarity with time series analysis, autocovariance functions, and the material in [Intuitive Math](intuitive_math.html).

---

## 1. Notation and Definitions

### 1.1 Active returns

Let $a_t = r_{P,t} - r_{B,t}$ denote the **active return** at time $t$, for $t=1,\ldots,T$.

Where:

- $r_{P,t}$ = portfolio return at time $t$
- $r_{B,t}$ = benchmark return at time $t$
- $T$ = total number of observations

### 1.2 Sample statistics

**Sample mean:**
$$
\bar{a} = \frac{1}{T}\sum_{t=1}^{T} a_t
$$

**Sample variance:**
$$
\widehat{\mathrm{Var}}(a) = \frac{1}{T-1}\sum_{t=1}^{T}(a_t - \bar{a})^2
$$

**Period tracking error:**
$$
TE_{\text{period}} = \sqrt{\widehat{\mathrm{Var}}(a)}
$$

### 1.3 Autocovariance function

The **lag-h autocovariance** is defined as:
$$
\gamma(h) = \mathrm{Cov}(a_t, a_{t+h}) = \mathbb{E}[(a_t - \mu)(a_{t+h} - \mu)]
$$

where $\mu = \mathbb{E}[a_t]$ is the population mean.

**Key properties:**

- $\gamma(0)$ = variance of $a_t$
- $\gamma(-h) = \gamma(h)$ (symmetry)
- $\gamma(h) \to 0$ as $h \to \infty$ for stationary processes

---

## 2. General Aggregation Formula

### 2.1 Variance of a sum with arbitrary autocovariance

For any stationary process, the variance of a sum of $m$ consecutive observations is:

$$
\mathrm{Var}\!\left(\sum_{i=1}^{m}a_i\right)
= \sum_{h=-(m-1)}^{m-1}(m-|h|)\gamma(h)
$$

Using symmetry $\gamma(-h) = \gamma(h)$, this simplifies to:

$$
\mathrm{Var}\!\left(\sum_{i=1}^{m}a_i\right)
= m\gamma(0) + 2\sum_{h=1}^{m-1}(m-h)\gamma(h)
$$

### 2.2 Interpretation

**First term:** $m\gamma(0)$ — the variance contribution if observations were independent

**Second term:** $2\sum_{h=1}^{m-1}(m-h)\gamma(h)$ — adjustment for serial correlation

- If $\gamma(h) > 0$ (positive autocorrelation), the sum variance **increases**
- If $\gamma(h) < 0$ (negative autocorrelation), the sum variance **decreases**
- If $\gamma(h) = 0$ (no autocorrelation), we recover $\mathrm{Var}(\sum a_i) = m\gamma(0)$

### 2.3 Connection to previous derivation

This is the general form of the equation from the [Intuitive Math](intuitive_math.html) page, where we had:
$$
\mathrm{Var}(A_m) = D\,\sigma_d^2 + 2\sum_{k=1}^{D-1}(D-k)\,\gamma_k
$$

Here, $\gamma(0) = \sigma_d^2$ and $\gamma(h) = \gamma_h$.

---

## 3. Annualization with Serial Correlation

### 3.1 True annual variance

For a year with $N$ base periods (e.g., $N=252$ trading days or $N=12$ months), the annual active return is:
$$
A = \sum_{t=1}^{N} a_t
$$

Its variance is:
$$
\mathrm{Var}(A) = N\gamma(0) + 2\sum_{h=1}^{N-1}(N-h)\gamma(h)
$$

### 3.2 True annual tracking error

The **exact annualized tracking error** is:
$$
TE_{\text{annual,true}} = \sqrt{N\gamma(0) + 2\sum_{h=1}^{N-1}(N-h)\gamma(h)}
$$

**Not** simply $TE_{\text{period}} \times \sqrt{N}$ unless $\gamma(h) = 0$ for all $h > 0$.

### 3.3 Comparison with naive scaling

The **naive scaling** (square-root-of-time rule) assumes:
$$
TE_{\text{annual,naive}} = TE_{\text{period}} \times \sqrt{N} = \sqrt{N\gamma(0)}
$$

The **ratio** of true to naive annualized TE is:
$$
\frac{TE_{\text{annual,true}}}{TE_{\text{annual,naive}}}
= \sqrt{1 + \frac{2}{N\gamma(0)}\sum_{h=1}^{N-1}(N-h)\gamma(h)}
$$

- Ratio > 1 → serial correlation **amplifies** annualized TE
- Ratio < 1 → serial correlation **dampens** annualized TE
- Ratio = 1 → no serial correlation (naive scaling is correct)

---

## 4. AR(1) Closed-Form Solution

### 4.1 Model specification

Assume active returns follow a **first-order autoregressive process**:
$$
a_t = \phi a_{t-1} + \varepsilon_t
$$

where:

- $\varepsilon_t \sim \mathcal{N}(0, \sigma_\varepsilon^2)$ are i.i.d. innovations
- $|\phi| < 1$ ensures stationarity
- $\phi > 0$ → persistence (momentum)
- $\phi < 0$ → mean reversion
- $\phi = 0$ → white noise

### 4.2 Autocovariance structure

For a stationary AR(1) process:

**Variance (lag-0):**
$$
\gamma(0) = \frac{\sigma_\varepsilon^2}{1 - \phi^2}
$$

**Lag-h autocovariance:**
$$
\gamma(h) = \gamma(0) \phi^{|h|}
$$

**Autocorrelation:**
$$
\rho(h) = \frac{\gamma(h)}{\gamma(0)} = \phi^{|h|}
$$

This shows exponential decay (or growth if $\phi < 0$) of correlations with lag.

### 4.3 Variance of m-period sum

Substituting the AR(1) autocovariance structure into the general formula:
$$
\mathrm{Var}(S_m) = \mathrm{Var}\!\left(\sum_{i=1}^{m}a_i\right)
= \gamma(0)\left[m + 2\sum_{h=1}^{m-1}(m-h)\phi^h\right]
$$

### 4.4 Closed-form sum identity

The weighted sum of geometric terms can be evaluated exactly:
$$
\sum_{h=1}^{m-1}(m-h)\phi^h
= m\frac{\phi - \phi^m}{1 - \phi}
- \frac{\phi(1 - m\phi^{m-1} + (m-1)\phi^m)}{(1-\phi)^2}
$$

**Derivation sketch:**

1. Start with $\sum_{h=1}^{m-1}(m-h)\phi^h = m\sum_{h=1}^{m-1}\phi^h - \sum_{h=1}^{m-1}h\phi^h$
2. Use $\sum_{h=1}^{m-1}\phi^h = \frac{\phi(1-\phi^{m-1})}{1-\phi}$ (geometric series)
3. Use $\sum_{h=1}^{m-1}h\phi^h = \frac{\phi(1-(m-1)\phi^{m-1}+m\phi^{m})}{(1-\phi)^2}$ (differentiate geometric series)
4. Combine and simplify

### 4.5 m-period tracking error for AR(1)

Combining the results:
$$
TE_{m}^{\text{AR(1)}} = \sqrt{\gamma(0)\left[m + 2\left(m\frac{\phi - \phi^m}{1 - \phi}
- \frac{\phi(1 - m\phi^{m-1} + (m-1)\phi^m)}{(1-\phi)^2}\right)\right]}
$$

This provides an **exact, closed-form solution** for tracking error at any horizon $m$ given parameters $(\phi, \sigma_\varepsilon)$.

---

## 5. Newey-West Robust Estimation

### 5.1 Motivation

In practice, we don't know the true autocovariance function $\gamma(h)$. We must estimate it from data. The **Newey-West estimator** provides a robust, heteroskedasticity- and autocorrelation-consistent (HAC) estimate of the long-run variance.

### 5.2 Long-run variance estimator

The **Newey-West long-run variance** is:
$$
\widehat{\sigma}_{\text{LR}}^2
= \hat{\gamma}(0) + 2\sum_{h=1}^{L}\left(1 - \frac{h}{L+1}\right)\hat{\gamma}(h)
$$

where:
- $\hat{\gamma}(h)$ = sample autocovariance at lag $h$
- $L$ = bandwidth (lag truncation parameter)
- Weights $w(h) = 1 - \frac{h}{L+1}$ are the **Bartlett kernel** weights, which decay linearly

### 5.3 Sample autocovariance

$$
\hat{\gamma}(h) = \frac{1}{T}\sum_{t=1}^{T-h}(a_t - \bar{a})(a_{t+h} - \bar{a})
$$

### 5.4 Bandwidth selection

Common rules of thumb:

- **Andrews (1991):** $L \approx \lfloor 4(T/100)^{2/9} \rfloor$ for AR(1) processes
- **Newey-West (1994):** $L \approx \lfloor 4(T/100)^{1/4} \rfloor$ for general processes
- **Rule of thumb:** $L \approx T^{1/3}$

For daily data with $T=252$, typical choices: $L \in [6, 10]$

### 5.5 Annualized tracking error (Newey-West)

$$
\widehat{TE}_{\text{annual,NW}} = \sqrt{N \cdot \widehat{\sigma}_{\text{LR}}^2}
$$

where $N$ is the number of base periods per year.

**Advantages:**

- Robust to model misspecification
- Consistent even with unknown autocorrelation structure
- Standard in econometrics and finance

**Disadvantages:**

- Requires choice of bandwidth $L$
- Less efficient than parametric methods (e.g., AR(1)) if model is correct

---

## 6. Implementation: AR(1) Helper Functions

### 6.1 Exact AR(1) tracking error

```{python}
import numpy as np

def te_m_ar1(phi, sigma_eps, m):
    """
    Compute m-period tracking error for AR(1) process.
    
    Parameters:
    -----------
    phi : float
        AR(1) coefficient, |phi| < 1
    sigma_eps : float
        Standard deviation of innovations
    m : int
        Number of periods to aggregate
    
    Returns:
    --------
    float
        m-period tracking error
    """
    # Stationary variance
    gamma0 = sigma_eps**2 / (1 - phi**2)
    
    # Sum of weighted autocovariances
    if np.abs(phi) < 1e-10:
        # phi ≈ 0 (white noise case)
        num = 0
    else:
        term1 = m * (phi - phi**m) / (1 - phi)
        term2 = phi * (1 - m*phi**(m-1) + (m-1)*phi**m) / (1 - phi)**2
        num = term1 - term2
    
    var_sm = gamma0 * (m + 2*num)
    return np.sqrt(var_sm)


def ar1_parameters_from_data(returns):
    """
    Estimate AR(1) parameters from data using OLS.
    
    Parameters:
    -----------
    returns : array-like
        Time series of active returns
    
    Returns:
    --------
    phi : float
        AR(1) coefficient
    sigma_eps : float
        Innovation standard deviation
    """
    returns = np.asarray(returns)
    y = returns[1:]
    x = returns[:-1]
    
    # OLS estimate of phi
    phi_hat = np.sum(x * y) / np.sum(x * x)
    
    # Residuals
    resid = y - phi_hat * x
    sigma_eps_hat = np.std(resid, ddof=1)
    
    return phi_hat, sigma_eps_hat
```

### 6.2 Example: Computing multi-horizon TE under AR(1)

```{python}
# Example parameters
phi = 0.3           # Moderate positive autocorrelation
sigma_eps = 0.01    # 1% daily innovation volatility

# Compute TE at different horizons
te_daily = te_m_ar1(phi, sigma_eps, m=1)
te_weekly = te_m_ar1(phi, sigma_eps, m=5)
te_monthly = te_m_ar1(phi, sigma_eps, m=21)
te_quarterly = te_m_ar1(phi, sigma_eps, m=63)
te_annual = te_m_ar1(phi, sigma_eps, m=252)

print("=" * 60)
print("Multi-Horizon Tracking Error (AR(1) with φ=0.3)")
print("=" * 60)
print(f"Daily:       {te_daily:.4f}  ({te_daily*100:.2f}%)")
print(f"Weekly:      {te_weekly:.4f}  ({te_weekly*100:.2f}%)")
print(f"Monthly:     {te_monthly:.4f}  ({te_monthly*100:.2f}%)")
print(f"Quarterly:   {te_quarterly:.4f}  ({te_quarterly*100:.2f}%)")
print(f"Annual:      {te_annual:.4f}  ({te_annual*100:.2f}%)")
print("=" * 60)

# Compare with naive scaling
te_annual_naive = te_daily * np.sqrt(252)
ratio = te_annual / te_annual_naive

print(f"\nNaive annual TE (√252 scaling): {te_annual_naive:.4f}")
print(f"True annual TE (AR(1) formula):  {te_annual:.4f}")
print(f"Ratio (True/Naive):              {ratio:.4f}")
print(f"→ Positive autocorrelation amplifies TE by {(ratio-1)*100:.1f}%")
```

---

## 7. Newey-West Implementation

```{python}
def newey_west_variance(returns, lags=None):
    """
    Compute Newey-West long-run variance estimator.
    
    Parameters:
    -----------
    returns : array-like
        Time series of active returns
    lags : int, optional
        Number of lags for autocovariance estimation.
        If None, uses rule of thumb: floor(T^(1/3))
    
    Returns:
    --------
    float
        Long-run variance estimate
    """
    returns = np.asarray(returns)
    T = len(returns)
    
    if lags is None:
        lags = int(np.floor(T**(1/3)))
    
    # Demean
    returns_dm = returns - np.mean(returns)
    
    # Sample variance (lag-0)
    gamma0 = np.mean(returns_dm**2)
    
    # Sum of weighted autocovariances
    acov_sum = 0.0
    for h in range(1, lags + 1):
        # Sample autocovariance at lag h
        gammah = np.mean(returns_dm[:-h] * returns_dm[h:])
        
        # Bartlett weight
        weight = 1 - h / (lags + 1)
        
        acov_sum += weight * gammah
    
    # Long-run variance
    sigma_lr_sq = gamma0 + 2 * acov_sum
    
    return sigma_lr_sq


def te_annualized_nw(returns, periods_per_year=252, lags=None):
    """
    Compute annualized tracking error using Newey-West estimator.
    
    Parameters:
    -----------
    returns : array-like
        Time series of active returns
    periods_per_year : int
        Number of base periods per year (252 for daily, 12 for monthly)
    lags : int, optional
        Bandwidth for Newey-West estimator
    
    Returns:
    --------
    float
        Annualized tracking error
    """
    sigma_lr_sq = newey_west_variance(returns, lags)
    te_annual = np.sqrt(periods_per_year * sigma_lr_sq)
    return te_annual


# Example with simulated AR(1) data
np.random.seed(42)
T = 252
phi_true = 0.4
sigma_eps_true = 0.01

# Simulate AR(1) process
a = np.zeros(T)
eps = np.random.normal(0, sigma_eps_true, T)
for t in range(1, T):
    a[t] = phi_true * a[t-1] + eps[t]

# Compute annualized TE different ways
te_naive = np.std(a) * np.sqrt(252)
te_nw = te_annualized_nw(a, periods_per_year=252)

# Estimate AR(1) and compute exact
phi_hat, sigma_eps_hat = ar1_parameters_from_data(a)
te_ar1 = te_m_ar1(phi_hat, sigma_eps_hat, m=252)

print("\n" + "=" * 60)
print("Annualized TE Comparison (Simulated AR(1) data, φ=0.4)")
print("=" * 60)
print(f"Naive (√252 scaling):        {te_naive:.4f}")
print(f"Newey-West estimator:        {te_nw:.4f}")
print(f"AR(1) closed-form:           {te_ar1:.4f}")
print(f"Estimated φ:                 {phi_hat:.4f}")
print("=" * 60)
```

---

## 8. Practical Guidance and Interpretation

### 8.1 When to use each method

| **Method** | **When to use** | **Pros** | **Cons** |
|------------|----------------|----------|----------|
| **Naive scaling** ($\sqrt{N}$) | No serial correlation detected | Simple, transparent | Biased if autocorrelation exists |
| **AR(1) closed-form** | Data fits AR(1) well, small samples | Efficient, exact | Misspecified if not AR(1) |
| **Newey-West** | Unknown autocorrelation structure, large samples | Robust, model-free | Requires bandwidth choice, less efficient |

### 8.2 Interpreting φ values

| **φ range** | **Interpretation** | **TE scaling** |
|-------------|-------------------|----------------|
| $\phi \approx 0$ | No serial correlation, white noise | Naive $\sqrt{N}$ scaling works |
| $0 < \phi < 0.5$ | Mild momentum, moderate persistence | Annual TE 5-15% higher than naive |
| $0.5 \leq \phi < 1$ | Strong momentum, high persistence | Annual TE 15-50%+ higher than naive |
| $-0.5 < \phi < 0$ | Mild mean reversion | Annual TE 5-15% lower than naive |
| $-1 < \phi \leq -0.5$ | Strong mean reversion | Annual TE 15-40% lower than naive |

### 8.3 Empirical findings in equity portfolios

Based on academic literature and industry practice:

- **Momentum/Growth tilts:** $\phi \in [0.2, 0.5]$ (positive persistence)
- **Value tilts:** $\phi \in [-0.1, 0.1]$ (near random walk)
- **High-frequency trading:** $\phi \in [-0.3, 0]$ (mean reversion)
- **ESG screens:** $\phi \in [0, 0.2]$ (mild persistence)

### 8.4 Reporting best practices

When reporting tracking error, always specify:

1. **Data frequency:** Daily, weekly, monthly?
2. **Sample period:** What date range?
3. **Annualization method:** Naive, AR(1), Newey-West?
4. **Lag structure:** If using Newey-West, what bandwidth?
5. **Assumptions:** Any filters, outlier treatment, etc.?

**Example:**
> "Daily tracking error over the past 12 months was 0.81%, corresponding to an annualized TE of 12.9% using Newey-West estimation with 8 lags. Estimated AR(1) coefficient: φ=0.28, indicating mild positive autocorrelation."

---

## 9. Worked Example: Comparing Methods

Let's work through a complete example comparing all three methods.

```{python}
# Generate realistic monthly active returns
np.random.seed(123)
n_months = 60  # 5 years of monthly data

# Simulate AR(1) process with moderate persistence
phi = 0.35
sigma_eps = 0.015  # 1.5% monthly innovation vol
a_monthly = np.zeros(n_months)
eps = np.random.normal(0, sigma_eps, n_months)
for t in range(1, n_months):
    a_monthly[t] = phi * a_monthly[t-1] + eps[t]

# Method 1: Naive scaling
te_monthly_naive = np.std(a_monthly, ddof=1)
te_annual_naive = te_monthly_naive * np.sqrt(12)

# Method 2: AR(1) parametric
phi_est, sigma_eps_est = ar1_parameters_from_data(a_monthly)
te_annual_ar1 = te_m_ar1(phi_est, sigma_eps_est, m=12)

# Method 3: Newey-West
lags_nw = int(np.floor(n_months**(1/3)))  # ≈ 4 lags
te_annual_nw = te_annualized_nw(a_monthly, periods_per_year=12, lags=lags_nw)

# Display results
print("\n" + "=" * 70)
print("Worked Example: 60 Months of Active Returns")
print("=" * 70)
print(f"True AR(1) parameters:     φ = {phi:.3f}, σ_ε = {sigma_eps:.4f}")
print(f"Estimated parameters:      φ̂ = {phi_est:.3f}, σ̂_ε = {sigma_eps_est:.4f}")
print("-" * 70)
print(f"Monthly TE (sample):       {te_monthly_naive:.4f}  ({te_monthly_naive*100:.2f}%)")
print("-" * 70)
print("ANNUALIZED TRACKING ERROR:")
print(f"  1. Naive (√12 scaling):  {te_annual_naive:.4f}  ({te_annual_naive*100:.2f}%)")
print(f"  2. AR(1) closed-form:    {te_annual_ar1:.4f}  ({te_annual_ar1*100:.2f}%)")
print(f"  3. Newey-West (L={lags_nw}):    {te_annual_nw:.4f}  ({te_annual_nw*100:.2f}%)")
print("-" * 70)
print(f"Ratio (AR(1)/Naive):       {te_annual_ar1/te_annual_naive:.4f}")
print(f"Ratio (NW/Naive):          {te_annual_nw/te_annual_naive:.4f}")
print("-" * 70)
print(f"Interpretation: Positive autocorrelation (φ̂={phi_est:.2f}) causes")
print(f"annualized TE to be ~{(te_annual_ar1/te_annual_naive - 1)*100:.1f}% higher than naive scaling predicts.")
print("=" * 70)
```

---

## 10. Connection to Previous Pages

This page extends the framework developed in earlier sections:

### From Overview ([Index](index.html))
- **Intuition:** Persistent drift vs mean reversion
- **Practical implications:** Why TE scaling matters for risk management
- **Economic drivers:** Sector momentum, factor persistence

### From Intuitive Math ([Full Derivation](intuitive_math.html))
- **Variance-of-a-sum formula:** $\mathrm{Var}(A_m) = D\sigma_d^2 + 2\sum(D-k)\gamma_k$
- **Monthly/daily TE ratio:** Depends on $\sum(D-k)\gamma_k$
- **Interpretation:** Autocovariance determines TE scaling

### Advanced topics (this page)
- **AR(1) parameterization:** Explicitly model $\gamma_k = \gamma(0)\phi^k$
- **Closed-form solutions:** Exact formulas for any horizon
- **Robust estimation:** Newey-West for unknown autocorrelation structure

---

## 11. Key Takeaways

1. **General aggregation formula** works for any autocovariance structure: $\mathrm{Var}(\sum a_i) = m\gamma(0) + 2\sum_{h=1}^{m-1}(m-h)\gamma(h)$

2. **AR(1) processes** provide tractable, closed-form solutions for multi-horizon TE with exponentially decaying autocorrelations.

3. **Newey-West estimator** offers a robust, model-free approach to annualization that handles unknown autocorrelation structures.

4. **Naive √N scaling** is only correct when $\gamma(h)=0$ for all $h>0$; otherwise it systematically biases TE estimates.

5. **Positive φ** (momentum) → annual TE higher than naive scaling predicts; **negative φ** (mean reversion) → annual TE lower.

6. **Best practice:** Always report estimation method and test for serial correlation before annualizing.

---

## 12. References and Further Reading

### Academic papers
- **Grinold, R. C., & Kahn, R. N. (2000).** *Active Portfolio Management: A Quantitative Approach for Producing Superior Returns and Controlling Risk* (2nd ed.). McGraw-Hill.
  
- **Newey, W. K., & West, K. D. (1987).** "A Simple, Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix." *Econometrica*, 55(3), 703-708.

- **Andrews, D. W. K. (1991).** "Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation." *Econometrica*, 59(3), 817-858.

- **Lo, A. W. (2002).** "The Statistics of Sharpe Ratios." *Financial Analysts Journal*, 58(4), 36-52.

### Industry resources
- CFA Institute curriculum: Active Risk and Tracking Error
- GIPS (Global Investment Performance Standards) guidelines on TE calculation
- Risk management frameworks from major asset managers

---

## 13. Navigation & Resources

### Related pages
- ← [Overview: Tracking Error Across Time Horizons](index.html)
- ← [Intuitive Math: Complete Derivation](intuitive_math.html)

### Interactive tools
- **Live App:** [Tracking Error Lab on Streamlit](https://tracking-error-lab-kgkju98o4pqxdjoevqtsay.streamlit.app/)
- **Source Code:** [GitHub Repository](https://github.com/TejasViswa/tracking-error-lab)

### Suggested workflow
1. **Start with [Overview](index.html)** for intuition and practical implications
2. **Read [Intuitive Math](intuitive_math.html)** for complete derivation of variance-of-a-sum formula
3. **Study this page** for advanced tools: AR(1) models, Newey-West estimation, closed-form solutions
4. **Experiment with the [interactive app](https://tracking-error-lab-kgkju98o4pqxdjoevqtsay.streamlit.app/)** using your own data
